# Forky
Author: Samuel  

#### URL
https://play.picoctf.org/practice/challenge/24  

#### Description
In this program, identify the last integer value that is passed as parameter to the function doNothing().  

<br>
<br>
<br>
<br>

## 解答の過程
「this program」部分のリンクをクリックするとファイルをダウンロードすることができます。  
ファイル名は「vuln」です。  
Linuxのfileコマンドで確認するとELF形式のバイナリーファイルです。  

```
$ file vuln
vuln: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=836c8d5ecaad6d64f4a358cf73d060d0c5050e87, not stripped
```

試しに実行しても、何も出力なく終了してしまうため、何が起きているのか分かりません。  
問題文には、「doNothing()に渡されるパラメーターとして最後の（最新の）整数を特定せよ」と書かれているので、リバースエンジニアリングする必要がありそうです。  

そこで、Ghidraを使ってファイルを確認してみます。  

### Ghidraでの作業
Ghidraを起動し、適当なプロジェクトを用意します。  
「File」＞「Import」を選択し、用意したプロジェクトにvulnをインポートします。Ghidraが自動的にファイルを認識してくれるので、出てくるダイアログではOKボタンなど肯定的に選択して進めます。  
プロジェクト内にインポートされたvulnをダブルクリックして、Code Browserを起動します。ファイルを解析するかどうかを尋ねるダイアログが表示されるので、これも肯定的に選択して進めます。  
解析が終わると、下図のように、Listing画面にvulnの解析結果であるバイナリーコードが表示されます。右側のデコンパイル画面にはmain()のデコンパイル結果を表示させています。  

![challenge-24--figure1.png](pictures/challenge-24--figure1.png)

main()は以下のコードです。  
```
undefined4 main(void)
{
  int *piVar1;
  
  piVar1 = (int *)mmap((void *)0x0,4,3,0x21,-1,0);
  *piVar1 = 1000000000;
  fork();
  fork();
  fork();
  fork();
  *piVar1 = *piVar1 + 0x499602d2;
  doNothing(*piVar1);
  return 0;
}
```

doNoting()のパラメーターとして、piVar1のポインターを渡しています。この「*piVar1」の値がどうなるかを調べれば良いことになります。  

doNothing()に至るまで、mmap()とfork()が呼ばれています。  
mmap()は、piVar1のアドレスを決める処理なので、無視します。  
\*piVar1の初期値として1000000000がセットされ、その後fork()が4回呼び出されています。その後、*piVar1に対して0x499602d2が足されています。  

fork()が複数回呼び出されていることによって、*piVar1は素直に0x499602d2を足すだけでは終わりません。どのように計算されるかを把握する必要があることが分かります。  

### fork()とは
fork()はUNIX系OSにおけるシステムコールで、現在のプロセス（親プロセス）を複製して新しいプロセス（子プロセス）を生成するために使われます。  

親プロセスがfork()を呼び出すと、  
1. 親プロセスのアドレス空間をコピーして新しいプロセスを作成します
2. これにより、親とほぼ同じ状態の子プロセスができます
3. そして、親と子ともに次の処理命令を実行していきます

つまり、以下のようなイメージでfork()が呼び出されるごとに子プロセスが増えて、*piVar1 = *piVar1 + 0x499602d2が計算され、doNothing()が呼び出されることになります。  
なお、下のイメージにおける括弧内の数字は便宜的に付けたもので、プロセスが作成された順序を想定したものです。  

| fork()の実行 | 1回目             | 2回目            | 3回目             | 4回目              |
| :-------- | :-------------- | :------------- | :-------------- | :--------------- |
| 親プロセス(1)  | → 親プロセス(1)      | → 親プロセス(1)     | → 親プロセス(1)      | → 親プロセス(1)       |
|           | ｜<br>｜          | ｜<br>｜         | ｜<br>｜          | ｜<br>→子プロセス(9)   |
|           | ｜<br>｜          | ｜<br>｜         | ｜<br>→子プロセス(5)  | <br>→ 子プロセス(5)   |
|           | ｜<br>｜          | ｜<br>｜         |                 | ｜<br>→ 子プロセス(10) |
|           | ｜<br>｜          | ｜<br>→子プロセス(3) | <br>→子プロセス(3)   | <br>→子プロセス(3)    |
|           | ｜<br>｜          |                | ｜<br>｜          | ｜<br>→ 子プロセス(11) |
|           | ｜<br>｜          |                | ｜<br>→ 子プロセス(6) | <br>→ 子プロセス(6)   |
|           | ｜<br>｜          |                |                 | ｜<br>→ 子プロセス(12) |
|           | ｜<br>→ 子プロセス(2) | <br>→ 子プロセス(2) | <br>→ 子プロセス(2)  | <br>→ 子プロセス(2)   |
|           |                 | ｜<br>｜         | ｜<br>｜          | ｜<br>→子プロセス(13)  |
|           |                 | ｜<br>｜         | ｜<br>→子プロセス(7)  | <br>→ 子プロセス(7)   |
|           |                 | ｜<br>｜         |                 | ｜<br>→ 子プロセス(14) |
|           |                 | ｜<br>→子プロセス(4) | <br>→子プロセス(4)   | <br>→子プロセス(4)    |
|           |                 |                | ｜<br>｜          | ｜<br>→ 子プロセス(15) |
|           |                 |                | ｜<br>→ 子プロセス(8) | <br>→ 子プロセス(8)   |
|           |                 |                |                 | ｜<br>→ 子プロセス(16) |

### コードの分析
以上より、fork()が4回呼び出されることによって2^4=16個のプロセスが生成され、*piVar1は以下のように計算されることになります。  

	*piVar1 = 1000000000 + (16 * 0x499602d2)

vulnは32bitのプログラムであることに注意する必要があります。この計算では桁あふれが生じるので、32bitに留めるようにしないといけません。また、int型で変数を宣言しているので、符号付になります。  
計算は、Windowsの電卓アプリで求めます。Pythonなどで計算させるのでも良いでしょう。  
結果は、-721750240になります。  
得られた値を所定のフォーマットにすることでフラグになります。  

<br>
<br>
<br>
<br>

## フラグ
picoCTF{-721750240}  

<br>
<br>

## この問題は
forkの仕組みについて学ぶことができます。  
